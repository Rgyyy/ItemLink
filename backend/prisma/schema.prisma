generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                 String               @id @default(uuid())
  email              String               @unique
  username           String               @unique
  passwordHash       String               @map("password_hash")
  fullName           String?              @map("full_name")
  phone              String?
  avatarUrl          String?              @map("avatar_url")
  isVerified         Boolean              @default(false) @map("is_verified")
  isActive           Boolean              @default(true) @map("is_active")
  balance            Decimal              @default(0) @db.Decimal(12, 2)
  createdAt          DateTime             @default(now()) @map("created_at")
  updatedAt          DateTime             @updatedAt @map("updated_at")
  role               Role                 @default(USER)
  favorites          Favorite[]
  items              Item[]
  receivedMessages   Message[]            @relation("ReceiverMessages")
  sentMessages       Message[]            @relation("SenderMessages")
  receivedReviews    Review[]             @relation("RevieweeReviews")
  sentReviews        Review[]             @relation("ReviewerReviews")
  boughtTransactions Transaction[]        @relation("BuyerTransactions")
  soldTransactions   Transaction[]        @relation("SellerTransactions")
  paymentTransactions PaymentTransaction[]
  bankAccounts       BankAccount[]
  rating             UserRating?

  @@map("users")
}

model Game {
  id          String         @id @default(uuid())
  name        String
  slug        String         @unique
  description String?
  imageUrl    String?        @map("image_url")
  isActive    Boolean        @default(true) @map("is_active")
  createdAt   DateTime       @default(now()) @map("created_at")
  updatedAt   DateTime       @updatedAt @map("updated_at")
  categories  ItemCategory[]
  items       Item[]

  @@map("games")
}

model ItemCategory {
  id          String   @id @default(uuid())
  gameId      String   @map("game_id")
  name        String
  slug        String
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  game        Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  items       Item[]

  @@unique([gameId, slug])
  @@map("item_categories")
}

model Item {
  id           String        @id @default(uuid())
  sellerId     String        @map("seller_id")
  gameId       String        @map("game_id")
  categoryId   String?       @map("category_id")
  title        String
  description  String
  price        Decimal       @db.Decimal(12, 2)
  quantity     Int           @default(1)
  server       String?
  images       String[]      @default([])
  views        Int           @default(0)
  createdAt    DateTime      @default(now()) @map("created_at")
  updatedAt    DateTime      @updatedAt @map("updated_at")
  itemType     ItemType      @map("item_type")
  tradeType    TradeType     @default(SELL) @map("trade_type")
  status       ItemStatus    @default(AVAILABLE)
  favorites    Favorite[]
  category     ItemCategory? @relation(fields: [categoryId], references: [id])
  game         Game          @relation(fields: [gameId], references: [id], onDelete: Cascade)
  seller       User          @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  transactions Transaction[]

  @@index([sellerId])
  @@index([gameId])
  @@index([categoryId])
  @@index([status])
  @@index([tradeType])
  @@index([createdAt(sort: Desc)])
  @@map("items")
}

model Transaction {
  id              String            @id @default(uuid())
  itemId          String            @map("item_id")
  sellerId        String            @map("seller_id")
  buyerId         String            @map("buyer_id")
  quantity        Int
  totalPrice      Decimal           @map("total_price") @db.Decimal(12, 2)
  paymentMethod   String?           @map("payment_method")
  meetingLocation String?           @map("meeting_location")
  notes           String?
  createdAt       DateTime          @default(now()) @map("created_at")
  updatedAt       DateTime          @updatedAt @map("updated_at")
  completedAt     DateTime?         @map("completed_at")
  status          TransactionStatus @default(PENDING)
  messages        Message[]
  reviews         Review[]
  buyer           User              @relation("BuyerTransactions", fields: [buyerId], references: [id], onDelete: Cascade)
  item            Item              @relation(fields: [itemId], references: [id], onDelete: Cascade)
  seller          User              @relation("SellerTransactions", fields: [sellerId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([buyerId], map: "idx_transactions_buyer")
  @@index([itemId], map: "idx_transactions_item")
  @@index([sellerId], map: "idx_transactions_seller")
  @@map("transactions")
}

model Review {
  id            String      @id @default(uuid())
  transactionId String      @map("transaction_id")
  reviewerId    String      @map("reviewer_id")
  revieweeId    String      @map("reviewee_id")
  rating        Int
  comment       String?
  createdAt     DateTime    @default(now()) @map("created_at")
  reviewee      User        @relation("RevieweeReviews", fields: [revieweeId], references: [id], onDelete: Cascade)
  reviewer      User        @relation("ReviewerReviews", fields: [reviewerId], references: [id], onDelete: Cascade)
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@unique([transactionId, reviewerId])
  @@index([revieweeId], map: "idx_reviews_reviewee")
  @@map("reviews")
}

model UserRating {
  userId         String   @id @map("user_id")
  totalReviews   Int      @default(0) @map("total_reviews")
  averageRating  Decimal  @default(0) @map("average_rating") @db.Decimal(3, 2)
  totalSales     Int      @default(0) @map("total_sales")
  totalPurchases Int      @default(0) @map("total_purchases")
  updatedAt      DateTime @updatedAt @map("updated_at")
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_ratings")
}

model Favorite {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  itemId    String   @map("item_id")
  createdAt DateTime @default(now()) @map("created_at")
  item      Item     @relation(fields: [itemId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
  @@map("favorites")
}

model Message {
  id            String      @id @default(uuid())
  transactionId String      @map("transaction_id")
  senderId      String      @map("sender_id")
  receiverId    String      @map("receiver_id")
  content       String
  isRead        Boolean     @default(false) @map("is_read")
  createdAt     DateTime    @default(now()) @map("created_at")
  receiver      User        @relation("ReceiverMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  sender        User        @relation("SenderMessages", fields: [senderId], references: [id], onDelete: Cascade)
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@index([receiverId], map: "idx_messages_receiver")
  @@index([transactionId], map: "idx_messages_transaction")
  @@map("messages")
}

model PaymentTransaction {
  id                  String             @id @default(uuid())
  userId              String             @map("user_id")
  type                PaymentType
  amount              Decimal            @db.Decimal(12, 2)
  status              PaymentStatus      @default(PENDING)
  paymentMethod       PaymentMethod
  bankTransactionId   String?            @map("bank_transaction_id")
  bankAccountId       String?            @map("bank_account_id")
  description         String?
  failureReason       String?            @map("failure_reason")
  metadata            Json?
  createdAt           DateTime           @default(now()) @map("created_at")
  updatedAt           DateTime           @updatedAt @map("updated_at")
  completedAt         DateTime?          @map("completed_at")
  user                User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankAccount         BankAccount?       @relation(fields: [bankAccountId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([createdAt(sort: Desc)])
  @@map("payment_transactions")
}

model BankAccount {
  id                  String               @id @default(uuid())
  userId              String               @map("user_id")
  bankCode            String               @map("bank_code")
  bankName            String               @map("bank_name")
  accountNumber       String               @map("account_number")
  accountHolderName   String               @map("account_holder_name")
  isDefault           Boolean              @default(false) @map("is_default")
  isVerified          Boolean              @default(false) @map("is_verified")
  openBankingToken    String?              @map("openbanking_token")
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")
  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  paymentTransactions PaymentTransaction[]

  @@unique([userId, accountNumber])
  @@index([userId])
  @@map("bank_accounts")
}

enum Role {
  USER
  ADMIN
}

enum ItemType {
  GAME_MONEY
  ITEM
  ACCOUNT
  OTHER
}

enum TradeType {
  SELL
  BUY
}

enum ItemStatus {
  AVAILABLE
  RESERVED
  SOLD
  HIDDEN
}

enum TransactionStatus {
  PENDING
  PAYMENT_WAITING
  PAYMENT_COMPLETED
  IN_DELIVERY
  DELIVERED
  COMPLETED
  CANCELLED
  REFUNDED
}

enum PaymentType {
  DEPOSIT
  WITHDRAWAL
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum PaymentMethod {
  OPEN_BANKING
  CARD
  VIRTUAL_ACCOUNT
}
